/**
* @author Andrea Arosio (andrea.arosio@webresults.it)
* @date 13/07/2021
* @description HDT_UTL_Dependencies – Classe di utilità per la gestione della sequenzializzazione dei processi
*/
public inherited sharing class HDT_UTL_Dependencies {
    
    public static final String STATUS_BOZZA = 'Bozza';
    public static final String STATUS_LAVORAZIONE = 'In Lavorazione';
    public static final String STATUS_SEQUENZIALIZZATO = 'Sequenzializzato';

    private static final String PHASE_SEQUENZIALIZZATO = 'Sequenzializzato';

    private static final String MATCH_BILLING = 'Billing Profile';
    private static final String MATCH_ACCOUNT = 'Account';
    private static final String MATCH_SERVICE_POINT = 'Service Point';

    public static final String TIPOLOGY_SALES = 'Order';
    public static final String TIPOLOGY_POSTSALES = 'Case';

    /**
    * @author Andrea Arosio (andrea.arosio@webresults.it)
    * @description metodo per la gestione del processo di sequenzializzazione
    * @date 13/07/2021
    * @param1 List<ServiceRequest> struttura oggetti tecnici da sequenzializzare
    * @param2 Map<Id, sObject> mappa degli oggetti con i vecchi valori
    * @param3 String tipology : tipologia process Case|Order
    */
    public static void processSequentializationBefore(Map<Id,SObject> newSObjectMap,Map<Id,SObject> oldSObjectMap, String tipology){
        
        List<ServiceRequest__c> incomingProcesses = new List<ServiceRequest__c>();
        Map<Id,Order> orders = new Map<Id,Order>();
        Map<Id,Case> cases = new Map<Id,Case>();
        List<String> dependenciesCheckCs = new List<String>();
        for(CS_DependecyPhaseCheck__c dependecyPhaseCheck : CS_DependecyPhaseCheck__c.getAll().values()){
            dependenciesCheckCs.add(dependecyPhaseCheck.Phase__c);
        }
        if(tipology.equalsIgnoreCase(TIPOLOGY_SALES)){
            for(Order order : (List<Order>)newSObjectMap.values()){
                Order oldOrder = (Order)oldSObjectMap.get(order.ID);
                if(!oldOrder.Phase__c.equalsIgnoreCase(order.Phase__c) && dependenciesCheckCs.contains(order.Phase__c)){
                    orders.put(order.ID, order);
                }
            }
            if(orders.size()>0){
                try{
                    List<ServiceRequest__c> srs = [SELECT ID, ProcessType__c, Order__c, Type__c, ServicePointCode__c, Account__c, BillingProfile__c
                                    FROM ServiceRequest__c 
                                    WHERE Order__r.ID IN: orders.keySet()
                                    WITH SECURITY_ENFORCED];
                    for(ServiceRequest__c sr : srs){
                        sr.NextPhase__c = orders.get(sr.Order__c).Phase__c;
                        incomingProcesses.add(sr);
                    }
                }catch(Exception ex){
                    System.debug(ex.getMessage());
                }
            }
        }else if(tipology.equalsIgnoreCase(TIPOLOGY_POSTSALES)){
            for(Case caseProcess : (list<Case>)newSObjectMap.values()){
                Case oldCase = (Case)oldSObjectMap.get(caseProcess.ID);
                if(!String.IsEmpty(oldCase.Phase__c)){
                    if(!oldCase.Phase__c.equalsIgnoreCase(caseProcess.Phase__c) && dependenciesCheckCs.contains(caseProcess.Phase__c)){
                        cases.put(caseProcess.ID, caseProcess);
                    }
                }
            }
            if(cases.size()>0){
                try{
                    List<ServiceRequest__c> srs = [SELECT ID, ProcessType__c, Case__c, Type__c, ServicePointCode__c, Account__c, BillingProfile__c
                                    FROM ServiceRequest__c 
                                    WHERE Case__r.ID IN: cases.keySet()
                                    WITH SECURITY_ENFORCED];
                    for(ServiceRequest__c sr : srs){
                        sr.NextPhase__c = cases.get(sr.Case__c).Phase__c;
                        incomingProcesses.add(sr);
                    }
                    
                }catch(Exception ex){
                    System.debug(ex.getMessage());
                }
            }
        }
        
        if(incomingProcesses.size()>0){
            Map<String, List<SObject>> processesToUpdate = sequentialization(incomingProcesses);
            
            if(processesToUpdate.size()>0){
                updateProcesses(processesToUpdate.get('serviceRequest'));
    
                if(tipology.equalsIgnoreCase(TIPOLOGY_SALES)){
                    for(Order order : (List<Order>)processesToUpdate.get('order')){
                        ((Order)newSObjectMap.get(order.ID)).Status = STATUS_SEQUENZIALIZZATO;
                        ((Order)newSObjectMap.get(order.ID)).Phase__c = PHASE_SEQUENZIALIZZATO;
                    }
                }else  if(tipology.equalsIgnoreCase(TIPOLOGY_POSTSALES)){
                    for(Case casePr : (List<Case>)processesToUpdate.get('case')){
                        ((Case)newSObjectMap.get(casePr.ID)).Status = STATUS_SEQUENZIALIZZATO;
                        ((Case)newSObjectMap.get(casePr.ID)).Phase__c = PHASE_SEQUENZIALIZZATO;
                    }
                }
            }
        }
    }

    /**
    * @author Andrea Arosio (andrea.arosio@webresults.it)
    * @description metodo per l'individuazione dei processi da sequnzializzare
    * @date 13/07/2021
    * @param1 List<ServiceRequest> struttura oggetti tecnici da sequenzializzare
    * @return Mappa dei processi da aggiornare
    */
    public static Map<String, List<SObject>> sequentialization(List<ServiceRequest__c> incomingProcesses){

        Map<String, List<SObject>> processesToUpdate = new Map<String, List<SObject>>();

        try {

            String conditions = 'WHERE ';
            Integer index = 0;
            for(ServiceRequest__c sr : incomingProcesses){
                index++;
                conditions += '(IncomingProcessType__c = \''+String.escapeSingleQuotes(sr.ProcessType__c)+'\' AND CheckingPhase__c = \''+String.escapeSingleQuotes(sr.NextPhase__c)+'\')';
                if(index < incomingProcesses.size()){
                    conditions += ' OR ';
                }
            }

            String queryDependenciesMatrix = 'SELECT Id, IncomingProcessType__c, BlockingProcessType__c, MatchingField__c '                                           
                        + 'FROM DependenciesMatrix__c '
                        + conditions 
                        + ' WITH SECURITY_ENFORCED';
            
            DependenciesMatrix__c[] dependencies = Database.query(queryDependenciesMatrix);

            Map<String,List<List<String>>> dependenciesMap = new Map<String,List<List<String>>>();
            for(DependenciesMatrix__c dependency : dependencies){
                if(dependenciesMap.containsKey(dependency.IncomingProcessType__c)){
                    dependenciesMap.get(dependency.IncomingProcessType__c).add(new List<String>{dependency.BlockingProcessType__c,dependency.MatchingField__c});
                }else{
                    List<List<String>> blockingMatches = new List<List<String>>();
                    blockingMatches.add(new List<String>{dependency.BlockingProcessType__c,dependency.MatchingField__c});
                    dependenciesMap.put(dependency.IncomingProcessType__c,blockingMatches);
                }
            }
            if(dependenciesMap.size()>0){
                processesToUpdate = getProcessesToUpdate(incomingProcesses, dependenciesMap);
            }
        } catch (Exception ex) {
            System.debug(ex.getMessage());
        }
        return processesToUpdate;
    }

    /**
    * @author Andrea Arosio (andrea.arosio@webresults.it)
    * @description metodo per la restituzione dell'elenco dei processi da sequnzializzare
    * @date 13/07/2021
    * @param1 List<ServiceRequest> struttura oggetti tecnici da sequenzializzare
    * @param2 Map<String,List<List<String>>> mappa delle dipendence
    * @return List<List<SObject>> Struttura dati processi da aggiornare
    */
    public static Map<String, List<SObject>> getProcessesToUpdate(List<ServiceRequest__c> incomingProcesses, Map<String,List<List<String>>> dependenciesMap){
        
        Map<String, List<SObject>> results = new Map<String, List<SObject>>();

        try {
            List<ServiceRequest__c> serviceRequestsToBeSequenced = new List<ServiceRequest__c>();
            List<Order> ordersToBeUpdated = new List<Order>();
            List<Case> casesToBeUpdated = new List<Case>();

            List<ServiceRequest__c> srBlockings = null;
            List<String> matchValueServicePoints = new List<String>();
            List<String> matchValueAccounts = new List<String>();
            List<String> matchValueBillings = new List<String>();
            List<String> matches = new List<String>();

            for(ServiceRequest__c sr : incomingProcesses){
                if(dependenciesMap.containsKey(sr.ProcessType__c)){
                    for(List<String> blockingMatches : dependenciesMap.get(sr.ProcessType__c)){
                        String blockingMatch = blockingMatches.get(1);
                        if(blockingMatch.equalsIgnoreCase(MATCH_SERVICE_POINT)){
                            matchValueServicePoints.add(sr.ServicePointCode__c);
                        }else if(blockingMatch.equalsIgnoreCase(MATCH_ACCOUNT)){
                            matchValueAccounts.add(sr.Account__c);
                        }else if(blockingMatch.equalsIgnoreCase(MATCH_BILLING)){
                            matchValueBillings.add(sr.BillingProfile__c);
                        }
                        matches.add(blockingMatches[0]);
                    }
                }
            }
            String queryServiceRequest = 'SELECT ID, Case__c, Order__c, Type__c, ProcessType__c, ServicePointCode__c, BillingProfile__c, Account__c '
                                    + 'FROM ServiceRequest__c '
                                    + 'WHERE (ServicePointCode__c IN :matchValueServicePoints OR Account__c IN :matchValueAccounts OR BillingProfile__c IN :matchValueBillings) AND '
                                    + 'Status__c = \''+String.escapeSingleQuotes(STATUS_LAVORAZIONE)+'\' AND '
                                    + 'ProcessType__c IN :matches '
                                    + 'WITH SECURITY_ENFORCED';

            try{
                srBlockings = (List<ServiceRequest__c>)Database.query(queryServiceRequest);
                String recordTypeVAS = Schema.SObjectType.Order.getRecordTypeInfosByDeveloperName().get('HDT_RT_VAS').getRecordTypeId();
                for(ServiceRequest__c sr : incomingProcesses){
                    Boolean valueToUpdate = true;
                    Boolean servicePoint = false;
                    Boolean account = false;
                    Boolean billing = false;

                    String blockingMatch = '';
                    List<String> bmatches = new List<String>();

                    if(dependenciesMap.containsKey(sr.ProcessType__c)){
                        for(List<String> blockingMatches : dependenciesMap.get(sr.ProcessType__c)){
                            blockingMatch = blockingMatches.get(1);
                            if(blockingMatch.equalsIgnoreCase(MATCH_SERVICE_POINT)){
                                servicePoint = true;
                            }else if(blockingMatch.equalsIgnoreCase(MATCH_ACCOUNT)){
                                account = true;
                            }else if(blockingMatch.equalsIgnoreCase(MATCH_BILLING)){
                                billing = true;
                            }
                            bmatches.add(blockingMatches[0]);
                        }
                    }

                    for(ServiceRequest__c srBlocking : srBlockings){
                        Boolean match = false;
                        if(bmatches.contains(srBlocking.ProcessType__c)){
                            if(servicePoint){
                                if(((String)sr.ServicePointCode__c).equalsIgnoreCase((String)srBlocking.ServicePointCode__c)){
                                    match = true;
                                }
                            }else if(account){
                                if(((String)sr.Account__c).equalsIgnoreCase((String)srBlocking.Account__c)){
                                    match = true;
                                }
                            }else if(billing){
                                if(((String)sr.BillingProfile__c).equalsIgnoreCase((String)srBlocking.BillingProfile__c)){
                                    match = true;
                                }
                            }
                        }
                        if(match && sr.Id != srBlocking.Id){
                            if(sr.Type__c.equalsIgnoreCase(TIPOLOGY_POSTSALES)){
                                Case caseToUpdate = new Case(ID=sr.Case__c);
                                caseToUpdate.Status = STATUS_SEQUENZIALIZZATO;
                                caseToUpdate.Phase__c = PHASE_SEQUENZIALIZZATO;
                                if(valueToUpdate){
                                    casesToBeUpdated.add(caseToUpdate);
                                }
                            }else if(sr.Type__c.equalsIgnoreCase(TIPOLOGY_SALES)){
                                Order orderToUpdate = [SELECT ID, RecordTypeId, OrderReference__c, IsBillableVas__c 
                                                        FROM Order 
                                                        WHERE ID =: sr.Order__c 
                                                        WITH SECURITY_ENFORCED];
                                orderToUpdate.Status = STATUS_SEQUENZIALIZZATO;
                                orderToUpdate.Phase__c = PHASE_SEQUENZIALIZZATO;
                                String orderRecordType = orderToUpdate.RecordTypeId;
                                if(orderRecordType.equalsIgnoreCase(recordTypeVAS) && (orderToUpdate.OrderReference__c == null && orderToUpdate.IsBillableVas__c == false)){
                                    valueToUpdate = false;
                                }
                                if(valueToUpdate){
                                    ordersToBeUpdated.add(orderToUpdate);
                                }
                            }
                            sr.DependOn__c = srBlocking.ID;
                            sr.Status__c = STATUS_SEQUENZIALIZZATO;
                            if(valueToUpdate){
                                serviceRequestsToBeSequenced.add(sr);
                            }

                            break;
                        }
                    }
                }
            }catch(Exception ex){
                System.debug(ex.getMessage());
            }
            
            results.put('serviceRequest',serviceRequestsToBeSequenced);
            results.put('case',casesToBeUpdated);
            results.put('order',ordersToBeUpdated);

        } catch (Exception ex) {
            System.debug(ex.getMessage());
        }

        return results;
    }

    /**
    * @author Andrea Arosio (andrea.arosio@webresults.it)
    * @description metodo per l'aggiornamento dei processi da sequnzializzare
    * @date 13/07/2021
    * @param1 List<ServiceRequest__c> serviceRequestsToBeSequenced
    * @param2 List<Order> ordersToBeUpdated
    * @param3 List<Case> casesToBeUpdated
    */
    public static void updateProcesses(List<ServiceRequest__c> serviceRequestsToBeSequenced){
        
        Savepoint sp = Database.setSavePoint();
        
        try{
            if (ServiceRequest__c.SObjectType.getDescribe().isAccessible()&&
                Schema.sObjectType.ServiceRequest__c.fields.Status__c.isAccessible()&&
                Schema.sObjectType.ServiceRequest__c.fields.Status__c.isUpdateable()&&
                Schema.sObjectType.ServiceRequest__c.fields.DependOn__c.isAccessible()&&
                Schema.sObjectType.ServiceRequest__c.fields.DependOn__c.isUpdateable()){
                
                update serviceRequestsToBeSequenced;
            }
        }catch(Exception ex){
            System.debug(ex.getMessage());
            Database.rollback(sp);
        }
    }
}